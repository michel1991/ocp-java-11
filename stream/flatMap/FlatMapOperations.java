package stream.flatMap;
import java.util.stream.*;
import java.util.*;
import java.util.Map.*;
import java.util.function.*;


public class FlatMapOperations {

    /**
    * Which of the following are true? (Choose all that apply.)

        A. Zero lines are generated by the line marked by peek 1.
        B. Two lines are generated by the line marked by peek 1.
        C. Three lines are generated by the line marked by peek 1.
        D. Zero lines are generated by the line marked by peek 2.
        E. Two lines are generated by the line marked by peek 2.
        F. Three lines are generated by the line marked by peek 2.
        G. The code does not compile.
        H. The code throws an exception.

        The Stream starts out containing three lists. Since we limit the size to 2, the third list is ignored.
        his means peek 2 is run twice—for x1 and x2—making option B correct.
        Then flatMap() runs, getting rid of the empty list and flattening out the three elements of x2.
        Now peek 2 sees these three elements, making option F correct.
        Finally, each of the three elements has 1 added to it, and those numbers (2, 3, and 4) are printed by the forEach().
     */
  static void printlnWithLimitFirstOperation(){
      List<Integer> x1 = Arrays.asList();
      List<Integer> x2 = Arrays.asList(1, 2, 3);
      List<Integer> x3 = Arrays.asList(4, 5, 6);
      Stream.of(x1, x2, x3)
            .limit(2)
            .peek(System.out::println) // peek 1
            .flatMap(x -> x.stream())
            .peek(System.out::println) // peek 2
            .map(x -> x + 1)
            .forEach(System.out::println);
   }

    /**
    * Which of the following statements are true about this code? (Choose all that apply.)
    *   A. It outputs: {}
        B. It outputs: {false=[], true=[]}
        C. If we changed line 31 from partitioningBy(notEmpty) to groupingBy(n -> n), it would output: {}
        D. If we changed line 31 from partitioningBy(notEmpty) to groupingBy(n -> n), it would output: {false=[], true=[]}
        E. The code does not compile.
        F. The code compiles but does not terminate at runtime.

        First, this mess of code does compile.
        While this code starts out with an infinite stream on line 23, it does become finite on line 24 thanks to limit(), making option F incorrect.
        The pipeline preserves only nonempty elements on line 25. Since there aren’t any of those, the pipeline is empty.
        Line 26 converts this to an empty map.
        Lines 27 and 28 create a Set with no elements and then another empty stream.
        Lines 29 and 30 convert the generic type of the Stream to List<String> and then String.
        Finally, line 31 gives us another Map<Boolean, List<String>>.
        The partitioningBy() operation always returns a map with two Boolean keys, even if there are no corresponding values.
        Therefore, option B is correct if the code is kept as is.
        By contrast, groupingBy() returns only keys that are actually needed, making option C correct if the code is modified on line 31.
     */
    static void partitionBy(){
        Predicate<String> empty = String::isEmpty; //  20:
        Predicate<String> notEmpty = empty.negate(); //  21:
        //22:
        var result = Stream.generate(() -> "") //   23:
                .limit(10) // 24:
                .filter(notEmpty) //  25:
                .collect(Collectors.groupingBy(k -> k)) //   26:
                .entrySet() // 27:
                .stream() //  28:
                .map(Entry::getValue) //  29:
                .flatMap(Collection::stream) //  30:
                .collect(Collectors.partitioningBy(notEmpty)); //  31:
                System.out.println(result); // 32:
    }

    /**
      What does the following output?
        A. [tire-][wheel-]
        B. tire-wheel-
        C. None of the above.
        D. The code does not compile

        The flatMap() method is used to turn a stream of collections
        into a one-dimensional stream.
        This means it gets rid of the empty list and flattens the other two.
        Option A is incorrect because this is the output you’d get using the regular map() method.
        Option B is correct because it flattens the elements.
        Notice how it doesn’t matter that all three elements are different types of Collection implementations.
     */
    public static void printireUnderscoreTWheelUnderscoreT(){
        Set<String> set = new HashSet<>();
        set.add("tire-");
        List<String> list = new LinkedList<>();
        Deque<String> queue = new ArrayDeque<>();
        queue.push("wheel-");
        Stream.of(set, list, queue)
           .flatMap(x -> x.stream())
           .forEach(System.out::print);

    }

    public static void main(String... args){
      printlnWithLimitFirstOperation();
      System.out.println();
   }

}