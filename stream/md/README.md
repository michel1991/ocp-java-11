###### Given the generic type String, the partitioningBy() collector
###### creates a Map<Boolean, List<String>> when passed to collect() by default.
###### When a downstream collector is passed to partitioningBy(),
##### which return types can be created? (Choose all that apply.)
*  A. Map<boolean, List<String>>
* B. Map<Boolean, List<String>>
* C. Map<Boolean, Map<String>>
* D. Map<Boolean, Set<String>>
* E. Map<Long, TreeSet<String>>
* F. None of the above

Options A and C do not compile, because they are invalid generic declarations.
Primitives are not allowed as generics, and Map must have two generic type parameters.
Option E is incorrect because partitioning only gives a Boolean key.
Options B and D are correct because they return a Map with
a Boolean key and a value type that can be customized to any Collection.



###### Which are true statements about terminal operations
###### in a stream that runs successfully? (Choose all that apply.)
* A. At most, one terminal operation can exist in a stream pipeline.
* B. Terminal operations are a required part of the stream pipeline in order to get a result.
* C. Terminal operations have Stream as the return type.
* D. The peek() method is an example of a terminal operation.
* E. The referenced Stream may be used after calling a terminal operation.

Terminal operations are the final step in a stream pipeline.
Exactly one is required, because it triggers the execution of the entire stream pipeline.
Therefore, options A and B are correct.
Option C is true of intermediate operations, rather than terminal operations.
Option D is incorrect because peek() is an intermediate operation.
Finally, option E is incorrect because once a stream pipeline is run, the Stream is marked invalid.

### Which of the following are true given this declaration? (Choose all that apply.)
```java
  var is = IntStream.empty();
```

* A. is.average() returns the type int.
* B. is.average() returns the type OptionalInt.
* C. is.findAny() returns the type int.
* D. is.findAny() returns the type OptionalInt.
* E. is.sum() returns the type int.
* F. is.sum() returns the type OptionalInt.

The average() method returns an OptionalDouble since averages of any type can result in a fraction.
Therefore, options A and B are both incorrect.
The findAny() method returns an OptionalInt because there might not be any elements to find.
Therefore, option D is correct.
The sum() method returns an int rather than an OptionalInt because the sum of an empty list is zero.
Therefore, option E is correct.

### What best describes a reduction?
*  A. A source operation that creates a small value
*  B. An intermediate operation where it filters the stream it receives
*  C. An intermediate operation where it mathematically divides each element in the stream
*  D. A terminal operation where a single value is generated by reading each element in the prior step in a stream pipeline
*  E. A terminal operation where one element is returned from the prior step in a stream pipeline without reading all the elements

The word reduction is used with streams for a terminal operation,
so options A, B, and C are incorrect.
Option E describes a valid terminal operation
like anyMatch(), but is not a reduction.
Option D is correct because a reduction has
to look at each element in the stream to determine the result.

### Which method can be applied to an existing Stream˂T˃ to return a stream with a different generic type?
* A. distinct()
* B. iterate()
* C. peek()
* D. sorted()
* E. filter()
* F. None of the above

The distinct() and filter() methods can reduce the number
of elements in a stream but do not change the generic type,
making options A and E incorrect.
The iterate() method creates a new stream and cannot be applied to an existing stream,
making option B incorrect.
The peek() and sorted() methods do not alter the generic type of the stream,
making options C and D incorrect. For these reasons, option F is correct.

###### What collector can turn the stream at left to the Map at right?
* A. Only grouping()
* B. Only groupingBy()
* C. Only partitioning()
* D. Only partitioningBy()
* E. Both grouping() and partitioning()
* F. Both groupingBy() and partitioningBy()

[image](images/map_collectors.jpg)
Both Collectors.groupingBy() and Collectors.partitioningBy()
are useful for turning a stream into a Map. The other two methods do not exist.
The partitioningBy() method automatically groups using a Boolean key.
However, we can also have a Boolean key with groupingBy().
For example, we could write s -˃ s.length() ˃ 3. Therefore, option F is correct.

#### The following figure represents a stream pipeline.
#### Given this, would the boxes X, Y, Z best represent?
[image](images/source_intermediate_terminal.jpg)
* A. Origin, intermediate operation, and final operation
* B. Origin, intermediate operation, and sink
* C. Origin, intermediate operation, and terminal operation
* D. Source, intermediate operation, and final operation
* E. Source, intermediate operation, and sink
* F. Source, intermediate operation, and terminal operation

The source is the first operation, and the terminal operation comes last,
making option F the answer. You need to know this terminology.

#### Suppose you have a stream with one element and the code stream.xxxx.forEach(System.out::println).
### Filling in xxxx from top to bottom in the table, how many elements can be printed out?
### Assume a valid lambda expression is passed to each method in the table.
[image](images/ilter_flatmap_map.png)

* A. Zero or one, zero or more, exactly one
* B. Zero or one, exactly one, zero or more
* C. Zero or one, zero or more, zero or more
* D. Exactly one, zero or more, exactly one
* E. Exactly one, exactly one, zero or more
* F. Exactly one, zero or more, zero or more

The filter() method either passes along a given element or doesn’t,
making options D, E, and F incorrect. The flatMap() method doesn’t pass along any elements
for empty streams. For nonempty streams, it flattens the elements, allowing it to return zero or more elements.
This makes option B incorrect. Finally, the map() method
applies a one-to-one function for each element. It has to return exactly one element,
so option A is the correct answer.






